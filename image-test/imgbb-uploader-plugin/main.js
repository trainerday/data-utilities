/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImgBBUploaderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiKey: "b53de65dae499fbb17ef3cc4e274e145",
  autoUpload: true,
  deleteLocalAfterUpload: true
};
var ImgBBUploaderPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("image", "Upload Images to ImgBB", (evt) => {
      this.uploadImagesInActiveFile();
    });
    this.addCommand({
      id: "upload-images-to-imgbb",
      name: "Upload all images in current file to ImgBB",
      callback: () => {
        this.uploadImagesInActiveFile();
      }
    });
    this.addCommand({
      id: "upload-selected-image",
      name: "Upload selected image to ImgBB",
      editorCallback: (editor, view) => {
        this.uploadSelectedImage(editor);
      }
    });
    if (this.settings.autoUpload) {
      this.registerEvent(
        this.app.vault.on("modify", (file) => {
          if (file instanceof import_obsidian.TFile && file.extension === "md") {
            setTimeout(() => {
              this.processFileForImages(file);
            }, 1e3);
          }
        })
      );
    }
    this.addSettingTab(new ImgBBSettingTab(this.app, this));
  }
  async uploadImagesInActiveFile() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) {
      new import_obsidian.Notice("No active markdown file");
      return;
    }
    const file = activeView.file;
    if (!file) {
      new import_obsidian.Notice("No file selected");
      return;
    }
    await this.processFileForImages(file);
  }
  async uploadSelectedImage(editor) {
    const selection = editor.getSelection();
    const cursor = editor.getCursor();
    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/;
    const match = selection.match(imageRegex);
    if (match) {
      const [fullMatch, altText, imagePath] = match;
      if (!imagePath.startsWith("http")) {
        const newUrl = await this.uploadLocalImage(imagePath, altText);
        if (newUrl) {
          editor.replaceSelection(`![${altText}](${newUrl})`);
          new import_obsidian.Notice("Image uploaded and link replaced!");
        }
      } else {
        new import_obsidian.Notice("Image is already a remote URL");
      }
    } else {
      new import_obsidian.Notice("Please select an image markdown link first");
    }
  }
  async processFileForImages(file) {
    if (!this.settings.apiKey) {
      new import_obsidian.Notice("Please set your ImgBB API key in settings");
      return;
    }
    const content = await this.app.vault.read(file);
    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
    let matches = [];
    let match;
    while ((match = imageRegex.exec(content)) !== null) {
      matches.push({
        fullMatch: match[0],
        altText: match[1],
        imagePath: match[2],
        index: match.index
      });
    }
    const localImages = matches.filter(
      (img) => !img.imagePath.startsWith("http") && !img.imagePath.startsWith("https")
    );
    if (localImages.length === 0) {
      return;
    }
    new import_obsidian.Notice(`Found ${localImages.length} local images. Uploading...`);
    let newContent = content;
    let uploadCount = 0;
    for (let i = localImages.length - 1; i >= 0; i--) {
      const img = localImages[i];
      const newUrl = await this.uploadLocalImage(img.imagePath, img.altText);
      if (newUrl) {
        const newMarkdown = `![${img.altText}](${newUrl})`;
        newContent = newContent.substring(0, img.index) + newMarkdown + newContent.substring(img.index + img.fullMatch.length);
        uploadCount++;
      }
    }
    if (uploadCount > 0) {
      await this.app.vault.modify(file, newContent);
      new import_obsidian.Notice(`Successfully uploaded ${uploadCount} images!`);
    }
  }
  async uploadLocalImage(imagePath, altText) {
    var _a;
    try {
      const imageFile = this.app.vault.getAbstractFileByPath(imagePath);
      if (!imageFile || !(imageFile instanceof import_obsidian.TFile)) {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView && activeView.file) {
          const currentDir = ((_a = activeView.file.parent) == null ? void 0 : _a.path) || "";
          const fullPath = currentDir ? `${currentDir}/${imagePath}` : imagePath;
          const relativeFile = this.app.vault.getAbstractFileByPath(fullPath);
          if (relativeFile && relativeFile instanceof import_obsidian.TFile) {
            return await this.uploadFileToImgBB(relativeFile, altText);
          }
        }
        console.warn(`Image file not found: ${imagePath}`);
        return null;
      }
      return await this.uploadFileToImgBB(imageFile, altText);
    } catch (error) {
      console.error("Error uploading image:", error);
      new import_obsidian.Notice(`Failed to upload image: ${imagePath}`);
      return null;
    }
  }
  async uploadFileToImgBB(file, altText) {
    var _a;
    try {
      const arrayBuffer = await this.app.vault.readBinary(file);
      const bytes = new Uint8Array(arrayBuffer);
      let binary = "";
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      const base64 = btoa(binary);
      const formData = new FormData();
      formData.append("key", this.settings.apiKey);
      formData.append("image", base64);
      formData.append("name", altText || file.name);
      const response = await fetch("https://api.imgbb.com/1/upload", {
        method: "POST",
        body: formData
      });
      const result = await response.json();
      if (result.success) {
        if (this.settings.deleteLocalAfterUpload) {
          await this.app.vault.delete(file);
        }
        return result.data.url;
      } else {
        throw new Error(((_a = result.error) == null ? void 0 : _a.message) || "Upload failed");
      }
    } catch (error) {
      console.error("ImgBB upload error:", error);
      new import_obsidian.Notice(`Upload failed: ${error.message}`);
      return null;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var ImgBBSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("ImgBB API Key").setDesc("Your ImgBB API key for uploading images").addText((text) => text.setPlaceholder("Enter your ImgBB API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Upload").setDesc("Automatically upload images when files are modified").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoUpload).onChange(async (value) => {
      this.plugin.settings.autoUpload = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Delete Local Images").setDesc("Delete local image files after successful upload").addToggle((toggle) => toggle.setValue(this.plugin.settings.deleteLocalAfterUpload).onChange(async (value) => {
      this.plugin.settings.deleteLocalAfterUpload = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "How to use:" });
    containerEl.createEl("p", { text: "1. Paste or drag images into your markdown files" });
    containerEl.createEl("p", { text: "2. Images will be automatically uploaded if Auto Upload is enabled" });
    containerEl.createEl("p", { text: "3. Or use the ribbon icon or command palette to upload manually" });
    containerEl.createEl("p", { text: "4. Local image links will be replaced with ImgBB URLs" });
  }
};
